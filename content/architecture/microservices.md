---
title: "Microservices Architecture"
date: 2017-11-06T11:14:26-05:00
description: "Microservices Architecture"
categories: []
keywords: [architecture]
menu:
  docs:
    parent: "architecture"
    weight: 10
weight: 10
aliases: []
toc: false
draft: false
---

Microservice architecture, or simply microservices, is a distinctive method of developing software 
systems that has grown in popularity in recent years. In fact, even though there isn’t a whole lot 
out there on what it is and how to do it, for many developers it has become a preferred way of 
creating enterprise applications.  Thanks to its scalability, this architectural method is considered 
particularly ideal when you have to enable support for a range of platforms and devices—spanning web, 
mobile, Internet of Things, and wearables—or simply when you’re not sure what kind of devices you’ll 
need to support in an increasingly cloudy future.

Speed and Safety at Scale and in Harmony.

If you’re like most software developers, team leaders, and architects responsible for getting 
working code out the door of your company, this phrase describes your job in a nutshell. Most 
of you have probably struggled at this, too. Getting to market quickly seems to imply giving 
up a bit of safety. Or, conversely, making sure the system is safe, reliable, and resilient 
means slowing down the pace of feature and bug-fix releases. And “at scale” is just a dream.

The three principals of the microservices architecture style.

* Microservices are ideal for big systems
* Microservice architecture is goal-oriented not solution-oriented
* Microservices are focused on replaceability

microservice applications share some important characteristics:

* Small in size
* Messaging enabled
* Bounded by contexts
* Autonomously developed
* Independently deployable
* Decentralized
* Built and released with automated processes


When you build software in this way, the cost of controlling and managing output increases 
significantly. In a microservice architecture, the services tend to get simpler, but the 
architecture tends to get more complex. That complexity is often managed with tooling, 
automation, and process.

When you first begin learning about microservice architecture it’s easy to get caught up in 
the tangible parts of the solution. You don’t have to look hard to find people who are excited 
about Docker, continuous delivery, or service discovery. All of these things can help you to 
build a system that sounds like the microservice systems we’ve been discussing. But 
microservices can’t be achieved by focusing on a particular set of patterns, process, or tools. 
Instead, you’ll need to stay focused on the goal itself—a system that can make change easier.

More specifically, the real value of microservices is realized when we focus on two key 
aspects—speed and safety. Every single decision you make about your software development ends 
up as a trade-off that impacts these two ideals. Finding an effective balance between them at 
scale is what we call the microservices way.

* The Speed of Change
* The Safety of Change
* At Scale
* In Harmony

The original intent of the microservice architecture concept—to replace complex monolithic 
applications with software systems made of replaceable components. 


Over the years, there are so many stories that big companies built their system in a microservices way. 
There are common goals and benefits that emerge from these implementation stories. The goal 
of improving software delivery speed as functional scope grows is realized through greater 
agility, higher composability, improved comprehensibility, independent service deployability, 
organizational alignment, and polyglotism. The goal of maintaining software system safety as 
scale increases is achieved through higher availability and resiliency, better efficiency, 
independent manageability and replaceability of components, increased runtime scalability, 
and more simplified testability.

### Speed
* Agility allows organizations to deliver new products, functions, and features more quickly and pivot more easily if needed.
* Composability reduces development time and provides a compound benefit through reusability over time.
* Comprehensibility of the software system simplifies development planning, increases accuracy, and allows new resources to come up to speed more quickly.
* Independent deployability of components gets new features into production more quickly and provides more flexible options for piloting and prototyping.
* Organizational alignment of services to teams reduces ramp-up time and encour‐ ages teams to build more complex products and features iteratively.
* Polyglotism permits the use of the right tools for the right task, thus accelerating technology introduction and increasing solution options.

### Safety

* Greater e ciency in the software system reduces infrastructure costs and reduces the risk of capacity-related service outages.
* Independent manageability contributes to improved efficiency, and also reduces the need for scheduled downtime.
* Replaceability of components reduces the technical debt that can lead to aging, unreliable environments.
* Stronger resilience and higher availability ensure a good customer experience.
* Better runtime scalability allows the software system to grow or shrink with the business.
* Improved testability allows the business to mitigate implementation risks.


# History

