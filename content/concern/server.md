---
title: "Server"
date: 2017-11-05T10:24:06-05:00
description: ""
categories: [concerns]
keywords: []
menu:
  docs:
    parent: "concern"
    weight: 95
weight: 95	#rem
aliases: []
toc: false
draft: false
reviewed: true
---

This module is responsible for managing the life cycle of the embedded Undertow core HTTP server. It starts the server and initializes all middleware handlers/plugins along with a route handler provider. It stops the server and allows the resources to be released even someone clicks CTRL+C on the terminal.

### Startup Hooks

During server startup, a list of startup hooks is called to initialize the context and environment for the server instance. For example, creating database connection pool, initialize cache.

All startup hooks must implement the following interface.

```
public interface StartupHookProvider {
    void onStartup();
}
```

Startup hooks are loaded from [service][] module and the config file to bind all startupHooksProviders is service.yml file. This file is in src/main/resources/config folder in your generated project from [light-codegen][] and it should be externalized for any official deployment environment. 

Here is an example.

```
# StartupHookProvider implementations, there are one to many and they are called in the same sequence defined.
- com.networknt.server.StartupHookProvider:
  - com.networknt.server.Test1StartupHook
  - com.networknt.server.Test2StartupHook
```


### Shutdown Hooks

During server shutdown, a list of shutdown hooks is called to clean up and release resources for the server instance. For example, close all the database connections in the connection pool and release any resource allocation.

All shutdown hooks must implement the following interface.

```
public interface ShutdownHookProvider {
    void onShutdown();
}
```

Shutdown hooks are loaded from the service module and the configuration is defined in service.yml file as startupHookProviders. Here is an example config section. 
 
```
# ShutdownHookProvider implementations, there are one to many and they are called in the same sequence defined.
- com.networknt.server.ShutdownHookProvider:
  - com.networknt.server.Test1ShutdownHook

```


### Middleware Handlers

Middleware handlers/plugins are the fundamental components in the framework as they perform the heavy lifting behind the scene. These components address the cross-cutting concerns for all API implementations so that API developers can focus on their domain business logic only. Each component has a config file (same name but with .yml/.yaml/.json extension) to control if the component is enabled and its behavior. The framework has provided a list of the middleware handlers/plugins, and experienced developers can add other plugins into the request/response chain. All middleware handlers in the request/response chain form an embedded gateway for the service running on top of it. 

Every middleware handler must implement the following interface.


```java
public interface MiddlewareHandler extends HttpHandler {

    /**
     * Get the next handler in the chain
     *
     * @return HttpHandler
     */
    HttpHandler getNext();

    /**
     * Set the next handler in the chain
     *
     * @param next HttpHandler
     * @return MiddlewareHandler
     */
    MiddlewareHandler setNext(final HttpHandler next);

    /**
     * Indicate if this handler is enabled or not.
     *
     * @return
     */
    boolean isEnabled();

    /**
     * Register this handler to the handler registration.
     */
    void register();

}

```


To add/remove/replace middleware handlers/plugins, update service.yml config file to bind them with MiddlewareHandler interface. These handlers/plugins will be executed in sequence for every incoming request. 

Here is the default middleware configuration generated by [light-codegen][] for RESTful API built with OpenAPI 3.0 specification. 

```yaml
- com.networknt.handler.MiddlewareHandler:
  # Exception Global exception handler that needs to be called first to wrap all middleware handlers and business handlers
  - com.networknt.exception.ExceptionHandler
  # Metrics handler to calculate response time accurately, this needs to be the second handler in the chain.
  - com.networknt.metrics.MetricsHandler
  # Traceability Put traceabilityId into response header from request header if it exists
  - com.networknt.traceability.TraceabilityHandler
  # Correlation Create correlationId if it doesn't exist in the request header and put it into the request header
  - com.networknt.correlation.CorrelationHandler
  # Parsing OpenAPI 3.0 specification based on request uri and method.
  - com.networknt.openapi.OpenApiHandler
  # Security JWT token verification and scope verification (depending on OpenApiHandler)
  - com.networknt.openapi.JwtVerifyHandler
  # Body Parse body based on content type in the header.
  - com.networknt.body.BodyHandler
  # SimpleAudit Log important info about the request into audit log
  - com.networknt.audit.AuditHandler
  # Sanitizer Encode cross site scripting
  - com.networknt.sanitizer.SanitizerHandler
  # Validator Validate request based on OpenAPI 3.0 specification (depending on OpenApiHandler and BodyHandler)
  - com.networknt.openapi.ValidatorHandler

```

### Route Provider

[light-codegen][] generates all the business domain handlers and corresponding test cases based on the specifications (OpenAPI 3.0, Swagger 2.0, GraphQL IDL and Hybrid Schema). The generated handlers output examples defined in the specification and test cases are commented out. The generator also generates a HandlerProvider class to wire in business domain handlers together into the request/response chain. These business handlers are located after request middleware handlers and before response middleware handlers. This class is loaded by the server during the server startup, and the binding is configured in service.yml file. 

Here is an example of the config.

```
# HandlerProvider implementation
- com.networknt.handler.HandlerProvider:
  - com.networknt.petstore.PathHandlerProvider
```



### Configuration

server.yml is the configuration file for the server module to control the server behavior. 

Here is an example of server.yml

```
# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true. It will be ignored if dynamicPort is true.
httpPort:  8080

# Enable HTTP should be false by default. It should be only used for testing with clients or tools
# that don't support https or very hard to import the certificate. Otherwise, https should be used.
# When enableHttp, you must set enableHttps to false, otherwise, this flag will be ignored. There is
# only one protocol will be used for the server at anytime. If both http and https are true, only
# https listener will be created and the server will bind to https port only.
enableHttp: false

# Https port if enableHttps is true. It will be ignored if dynamicPort is true.
httpsPort:  8443

# Enable HTTPS should be true on official environment and most dev environments.
enableHttps: true

# Http/2 is enabled by default for better performance and it works with the client module
enableHttp2: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: com.networknt.petstore-3.0.1

# Flag to enable self service registration. This should be turned on on official test and production. And
# dyanmicPort should be enabled if any orchestration tool is used like Kubernetes.
enableRegistry: false

# Dynamic port is used in situation that multiple services will be deployed on the same host and normally
# you will have enableRegistry set to true so that other services can find the dynamic port service. When
# deployed to Kubernetes cluster, the Pod must be annotated as hostNetwork: true
dynamicPort: false

# Minimum port range. This define a range for the dynamic allocated ports so that it is easier to setup
# firewall rule to enable this range. Default 2400 to 2500 block has 100 port numbers and should be
# enough for most cases unless you are using a big bare metal box as Kubernetes node that can run 1000s pods
minPort: 2400

# Maximum port rang. The range can be customized to adopt your network security policy and can be increased or
# reduced to ease firewall rules.
maxPort: 2500

# environment tag that will be registered on consul to support multiple instances per env for testing.
# https://github.com/networknt/light-doc/blob/master/docs/content/design/env-segregation.md
# This tag should only be set for testing env, not production. The production certification process will enforce it.
# environment: test1

```

### Config Server

If you want the server to load configuration files from config server, the following environment variable must be set in the java -jar as option or pass to Docker container as environment variables.

* light-env
* light-config-server-uri

Once the server starts, it will access the [light-config-server](https://github.com/networknt/light-config-server) instance to get a zip file that contains config files for the particular service for the environment and the framework version. The zip file will be deflated automatically and put all file into /config folder which is specified by light-4j-config-dir system properties. 

If you are deploying hundreds or thousands of services, it would be much easier to many the configurations with light-config-server which supports hierarchical config file management with multiple GitHub organizations and repositories. 


### Service Registry

If enableRegistry is true in server.yml, then the server will register itself to Consul or Zookeeper whichever is configured in service.yml. The self-registration is used in data center deployment which you might have several Java instances running on the same host. It is also used in Kubernetes cluster as all the services are running on host network to take advantages of direct service discovery. 

For self-registration, you can specify dynamicPort to true so that the server module will try to bind a port in a range defined between minPort and maxPort. 

### Port Allocation

If you are using service registry, you should only use HTTPS port and disable the HTTP port all the time. In fact, although we support HTTP connection, we recommend using HTTPS all the time even in the development environment as TLS is supported out of the box. 

When you are trying to sign the port number manually, be sure that there is no conflict on the same host. For some services running inside another container or service platform, there is a way to pass the HTTP or HTTPS port into the light-4j service from an environment variable. One example is to deploy light-4j service into Azure App Service platform. The port number must be allocated by the Azure App Service and pass to the internal service. 

The following environment variables are supported. 

```
httpPort
httpsPort
```

By setting above environment variables, the server.yml settings are overwritten. Please note, that you only need to set one port number and only enable HTTP or HTTPS. 

For more info about setting port number with environment variables, please refer to https://github.com/networknt/light-4j/issues/210

### Gracefully Shutdown

As we are using service registry, discovery and client-side load balance, our client module maintains a list of live services per serviceId interested. If any service is shutting down, it takes a short while to propagate to all clients. To handle in-flight request from the clients that don't know the server instance is down, the server has to send a shutdown signal to the registry(Consul or Zookeeper) and keep processing for at least 20 to 30 seconds and then shut down. Within this period of time, all client should have known the service instance is gone and won't send any new request to it.


### TLS Hostname Verification

For testing, we can disable the hostname verification on the client for the certificate; however, it is recommended that on production, hostname verification should be turned on to eliminate man-in-the-middle attacks. 

You have two options:

* Buy certificates from a CA like VeriSign.
* Setup a CA in your organization and use OpenSSL to generate certificates.

For more information

http://stackoverflow.com/questions/29546834/trust-not-trusted-certificates-and-skip-hostname-verification/29547114#29547114
https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning

[service]: /concern/service/
[light-codegen]: /tool/light-codegen/
