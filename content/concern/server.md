---
title: "Server"
date: 2017-11-05T10:24:06-05:00
description: ""
categories: [concerns]
keywords: []
menu:
  docs:
    parent: "concern"
    weight: 95
weight: 95	#rem
aliases: []
toc: false
draft: false
---

This module is responsible for managing life cycle of the embedded Undertow core 
http server. It starts the server and initializes all middleware plugins along 
with a route handler provider. It stops the server and allow the resources to be 
released even someone clicks CTRL+C.

### Startup Hooks

During server startup, a list of startup hooks will be called to initialize the
context and environment for the server instance. For example, creating database 
connection pool etc.

All startup hooks must implement the following interface.

```
public interface StartupHookProvider {
    void onStartup();
}
```

Startup hooks are loaded from [service][] module and the config file to bind all
startupHooksProviders is service.yml file. This file will in src/main/resources/config
folder in your generated project from [light-codegen][]

Here is an example.

```
# StartupHookProvider implementations, there are one to many and they are called in the same sequence defined.
- com.networknt.server.StartupHookProvider:
  - com.networknt.server.Test1StartupHook
  - com.networknt.server.Test2StartupHook
```


### Shutdown Hooks

During server shutdown, a list of shutdown hooks will be called to clean up and
release resources for the server instance. For example, close all the database
connections in the connection pool etc.

All shutdown hooks must implement the following interface.

```
public interface ShutdownHookProvider {
    void onShutdown();
}
```

Shutdown hooks are loaded from the service module and the configuration is defined
in service.yml file as startupHookProviders. Here is an example config section. 
 
```
# ShutdownHookProvider implementations, there are one to many and they are called in the same sequence defined.
- com.networknt.server.ShutdownHookProvider:
  - com.networknt.server.Test1ShutdownHook

```


### Middleware

Middleware plugins are the key components in the framework as they perform 
the heavy lifting behind the scene. These components address the cross 
cutting concerns for all API implementations so that API developers can 
focus on their domain logic only. Each component will have a config file 
(same name but with .yml/.yaml/.json ext) to control if the component will 
be enabled and its behavior. The framework has provide a list of the 
middleware plugins and experienced developers can add other plugins into 
the request/response chain.

Every middleware handler must implementation the following interface.

```java
public interface MiddlewareHandler extends HttpHandler {

    /**
     * Get the next handler in the chain
     *
     * @return HttpHandler
     */
    HttpHandler getNext();

    /**
     * Set the next handler in the chain
     *
     * @param next HttpHandler
     * @return MiddlewareHandler
     */
    MiddlewareHandler setNext(final HttpHandler next);

    /**
     * Indicate if this handler is enabled or not.
     *
     * @return
     */
    boolean isEnabled();

    /**
     * Register this handler to the handler registration.
     */
    void register();

}

```


To add your own middleware plugins, update service.yml config file to bind
them with MiddlewareHandler interface.

Here is the default middleware configuration generated by [light-codegen][] for
RESTful API built with OpenAPI 3.0 specification. 

```yaml
- com.networknt.handler.MiddlewareHandler:
  # Exception Global exception handler that needs to be called first to wrap all middleware handlers and business handlers
  - com.networknt.exception.ExceptionHandler
  # Metrics handler to calculate response time accurately, this needs to be the second handler in the chain.
  - com.networknt.metrics.MetricsHandler
  # Traceability Put traceabilityId into response header from request header if it exists
  - com.networknt.traceability.TraceabilityHandler
  # Correlation Create correlationId if it doesn't exist in the request header and put it into the request header
  - com.networknt.correlation.CorrelationHandler
  # Parsing OpenAPI 3.0 specification based on request uri and method.
  - com.networknt.openapi.OpenApiHandler
  # Security JWT token verification and scope verification (depending on OpenApiHandler)
  - com.networknt.openapi.JwtVerifyHandler
  # Body Parse body based on content type in the header.
  - com.networknt.body.BodyHandler
  # SimpleAudit Log important info about the request into audit log
  - com.networknt.audit.AuditHandler
  # Sanitizer Encode cross site scripting
  - com.networknt.sanitizer.SanitizerHandler
  # Validator Validate request based on OpenAPI 3.0 specification (depending on OpenApiHandler and BodyHandler)
  - com.networknt.openapi.ValidatorHandler


```

### Route Provider

[light-codegen][] generates all the handlers and corresponding test cases based on OpenAPI 
specification for RESTful APIs. Other API style(GraphQL, Hybrid etc) will have their own
input model to trigger the generation. The generator also generates a HandlerProvider instance
to group handlers together. This class is loaded by the server during the server startup and
the binding is configured in service.yml file. 

Here is an example of the config.

```
# HandlerProvider implementation
- com.networknt.server.HandlerProvider:
  - com.networknt.petstore.PathHandlerProvider

```

### Configuration

server.yml is the configuration file for the server module to control the 
server behavior. 

Here is an example of server.yml

```
# Server configuration
---
# This is the default binding address if the service is dockerized.
ip: 0.0.0.0

# Http port if enableHttp is true.
httpPort:  8080

# Enable HTTP should be false on official environment.
enableHttp: false

# Https port if enableHttps is true.
httpsPort:  8443

# Enable HTTPS should be true on official environment.
enableHttps: true

# Http/2 is enabled by default.
enableHttp2: true

# Keystore file name in config folder. KeystorePass is in secret.yml to access it.
keystoreName: tls/server.keystore

# Flag that indicate if two way TLS is enabled. Not recommended in docker container.
enableTwoWayTls: false

# Truststore file name in config folder. TruststorePass is in secret.yml to access it.
truststoreName: tls/server.truststore

# Unique service identifier. Used in service registration and discovery etc.
serviceId: com.networknt.petstore-1.0.1

# Flag to enable service registration. Only be true if running as standalone Java jar.
enableRegistry: false

# environment tag that will be registered on consul to support multiple instances per env for testing.
# https://github.com/networknt/light-doc/blob/master/docs/content/design/env-segregation.md
# This tag should only be set for testing env, not production. The production certification process will enforce it.
# environment: test1

```

### Config Server

As an option, the config files for the server instance can be retrieved from
[light-config-server](https://github.com/networknt/light-config-server) 
instance. This is only needed if you run your service as standalone Java jar
or standalone docker container. When Kubernetes is used, then the config files
will be mapped to Kubernetes ConfigMap and Secret. 

If you want the server to load configuration files from config server, the
following environment variable must be set in the java -jar as option or pass
to docker container as environment variables.

* light-env
* light-config-server-uri

Once the server starts, it will access the [light-config-server](https://github.com/networknt/light-config-server) 
instance to get a zip file that contains config files for this particular service for 
this environment and this framework version. The zip file will be deflated automatically
and put all file into /config folder which is specified by light-4j-config-dir
system properties.


### Service Registry

If enableRegistry is true in server.yml, then the server will register itself
to Consul or Zookeeper whichever is configured in service.yml. The self
registration is only needed if you are running the server along without
docker. When docker is used, you can use [Registrator](https://github.com/gliderlabs/registrator)
ffor service registration. 


### Gracefully Shutdown

As we are using service registry, discovery and client side load balance, our
client will maintain a list of live services per serviceId. If any service
is shutting down, it will take a short while to propagate to all clients. In
order to handle in-flight request from the clients that don't know the server
instance is down, the server has to send a shutdown signal to registry and keep
processing for at least 20 to 30 seconds and then shutdown. Within this period
of time, all client should have known the service instance is gone and won't
send any new request to it.


### TLS Hostname Verification

For testing, we can disable the hostname verification on the client for the 
certificate; however, it is recommended that on production, hostname 
verification should be turned on to eliminate man-in-the-middle attacks. 

You have two options:

* Buy certificates from a CA like VeriSign.
* Setup a CA in your organization and use openssl to generate certificate.

For more information

http://stackoverflow.com/questions/29546834/trust-not-trusted-certificates-and-skip-hostname-verification/29547114#29547114
https://www.owasp.org/index.php/Certificate_and_Public_Key_Pinning

[service]: /concern/service/
[light-codegen] /tool/light-codegen/
