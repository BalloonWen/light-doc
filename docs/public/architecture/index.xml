<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Architectures on Light Ecosystem for Microservices</title>
    <link>https://networknt.github.io/architecture/</link>
    <description>Recent content in Architectures on Light Ecosystem for Microservices</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <copyright>Released under the MIT license</copyright>
    <lastBuildDate>Thu, 10 Aug 2017 15:04:40 -0400</lastBuildDate>
    
	<atom:link href="https://networknt.github.io/architecture/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Transaction management in microservices architecture</title>
      <link>https://networknt.github.io/architecture/transaction/</link>
      <pubDate>Thu, 10 Aug 2017 15:04:40 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/transaction/</guid>
      <description>In traditional monolithic applications, we normally use distributed transactions(XA) and two-phase commit(2PC) to maintain data consistency and integrity.
After moving to microservices architecture, we don&amp;rsquo;t have the option to use XA correctly technically; however, a lot of developer will use it implicitly without knowing the risk. In fact, they don&amp;rsquo;t even realize that they are using distributed transactions between microservices.
What is a distributed transaction When we are talking about distributed transaction in monolithic world, we are talking about explicit distributed transactions.</description>
    </item>
    
    <item>
      <title>Platform</title>
      <link>https://networknt.github.io/architecture/platform/</link>
      <pubDate>Thu, 08 Jun 2017 09:37:00 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/platform/</guid>
      <description> Thre are five major elements of API platform
Runtime service management API testing API creation and delivery API management solution API life-cycle management </description>
    </item>
    
    <item>
      <title>API category and framework</title>
      <link>https://networknt.github.io/architecture/category/</link>
      <pubDate>Wed, 07 Jun 2017 12:58:56 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/category/</guid>
      <description>When an organization pursue microservices, the services/APIs can be grouped into the following categories. For each category, certain microservice style is more suitable than others.
Open Web APIs This is also called public API. Companies want to bring their business online to attract developers to build applications against their public APIs. In this way, they can extend their business and reach more customers than before.
Rest When doing so, it seems RESTful API is a natural choose as it is well known by almost every developer and support almost every language.</description>
    </item>
    
    <item>
      <title>Architecture</title>
      <link>https://networknt.github.io/architecture/</link>
      <pubDate>Wed, 25 Jan 2017 20:18:44 -0500</pubDate>
      
      <guid>https://networknt.github.io/architecture/</guid>
      <description>light-4j is aiming microservices and it has to be high throughput, low latency, light-weight and address a lot of cross-cutting concerns at the same time. It is based on Undertow Core Http server and depending on minimum third party libraries.
The topics here are architectural considerations. In a nutshell, architecture is a type of design where the focus is quality attributes and wide(er) scope whereas design focuses on functional requirements and more localized concerns.</description>
    </item>
    
    <item>
      <title>Integration Patterns</title>
      <link>https://networknt.github.io/architecture/integration/</link>
      <pubDate>Sat, 12 Nov 2016 20:55:44 -0500</pubDate>
      
      <guid>https://networknt.github.io/architecture/integration/</guid>
      <description>While working with my clients to transform monolithic Java EE applications to microservices architecture, one of the most frequently asked questions from my clients is how do you integrate your newly built microservices with existing Java EE applications. In other words, how to leverage existing application stacks when exposing REST APIs with microservices?
For most organizations especially financial institutions, they have big Java EE applications running on Weblogic/Websphere that they&amp;rsquo;ve invested efforts for a decade or longer.</description>
    </item>
    
    <item>
      <title>Monitoring</title>
      <link>https://networknt.github.io/architecture/monitoring/</link>
      <pubDate>Wed, 09 Nov 2016 21:13:27 -0500</pubDate>
      
      <guid>https://networknt.github.io/architecture/monitoring/</guid>
      <description>Monitoring used to be a somewhat passive thing. You used tools to monitor the application process/logs and perhaps send an alert if something seemed wrong,
but mostly it was hands off. When we move to microservices architecture, things are changing.
User Experience and Microservices Monitoring With Microservices which are released more often, you can try new features and see how they impact user usage patterns. With this feedback, you can improve your application.</description>
    </item>
    
    <item>
      <title>traceability</title>
      <link>https://networknt.github.io/architecture/traceability/</link>
      <pubDate>Sun, 06 Nov 2016 11:04:20 -0500</pubDate>
      
      <guid>https://networknt.github.io/architecture/traceability/</guid>
      <description>For microservices architecture, it is very important to trace request from one service to another in the entire call tree in order to have big picture if something happens or have an audit log that is aggregated by database or Splunk.
In the framework, we have two Ids to serve this purpose.
X-Traceability-Id  Generated by client Unique for this client only Can be database sequence number or UUID Must be passed to the next service Must be returned to the caller Will be logged in per request audit log  X-Correlation-Id  Generated in the immediate service from client Must be UUID Must be passed to the next service Will be logged in per request audit log Every service/API must check if this id available and generate one if doesn&amp;rsquo;t exist in request header.</description>
    </item>
    
    <item>
      <title>Plugin Architecture</title>
      <link>https://networknt.github.io/architecture/plugin/</link>
      <pubDate>Sat, 29 Oct 2016 17:22:16 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/plugin/</guid>
      <description>In the framework design, we have adopted the same principal of microservices architecture to break down the entire framework into smaller pieces so that each can be customized and replaced if necessary. The only difference is that all the modules in the framework are wired in request/response chain for best performance.
There are four type of components that can be wired in at different stage of the server start up.</description>
    </item>
    
    <item>
      <title>Security</title>
      <link>https://networknt.github.io/architecture/security/</link>
      <pubDate>Thu, 20 Oct 2016 14:34:09 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/security/</guid>
      <description>Note: If this is the first time you hear about OAuth2 or you want to get familiar with the grant types we are using, please read this article first.
Everyone’s excited about microservices, but actual implementation is sparse. Perhaps the reason is that people are unclear on how these services talk to one another; especially tricky thing is access management throughout a sea of independent services.
While designing microserivces, big monolithic application is breaking down to smaller services that can be independently deployed or replaced.</description>
    </item>
    
    <item>
      <title>API Gateway</title>
      <link>https://networknt.github.io/architecture/gateway/</link>
      <pubDate>Thu, 20 Oct 2016 14:33:53 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/gateway/</guid>
      <description>When your organization is thinking about breaking up the big monolithic application to adopt microservices architecture, chances are there are some vendors coming to sell their gateway solutions. Why they want to sell you gateways and do you really need a gateway?
The reason they are eagerly selling you a gateway is because they have to monetize their product as soon as possible before it is obsolete. The solutions they provided are not truely microservices as there is no standalone gateway in the picture of the real microservices architecture.</description>
    </item>
    
    <item>
      <title>Scalability</title>
      <link>https://networknt.github.io/architecture/scalability/</link>
      <pubDate>Tue, 11 Oct 2016 12:32:21 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/scalability/</guid>
      <description>##
One of the benefits utilizing microservices architecture is to make sure your application is easily scaling. When we talk about scalability, one of the best books is The Art of Scalability
It introduced the scale cube as following.
The Scale Cube consists of an X, Y and Z axes – each addressing a different approach to scale a service. The lowest left point of the cube (coordinates X=0, Y=0 and Z=0) represents the worst case monolithic service or product identified above: a product wherein all functions exist within a single code base on a single server making use of that server’s finite resources of memory, cpu speed, network ports, mass storage, etc.</description>
    </item>
    
    <item>
      <title>Spring is bloated</title>
      <link>https://networknt.github.io/architecture/spring-is-bloated/</link>
      <pubDate>Sun, 09 Oct 2016 08:15:27 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/spring-is-bloated/</guid>
      <description>Over the years, Spring seemed to be the replacement of JEE servers with IoC container and light weight servlet container as its foundation. Especially recently, Spring Boot brings in an easy development model and increases developer productivity dramatically.
However, there are two issues or limitations in Spring applications.
Spring is bloated and it becomes too heavy When Spring was out, it was only a small core with IoC contain and it was fast and easy to use.</description>
    </item>
    
    <item>
      <title>Microservices - The final nail in the coffin for Java EE</title>
      <link>https://networknt.github.io/architecture/jee-is-dead/</link>
      <pubDate>Sun, 09 Oct 2016 08:14:57 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/jee-is-dead/</guid>
      <description>When Java was out, big players like IBM, BEA, Oracle etc. saw a great opportunity to make money as it is a great language for web programming. But how can you make big money around a programming language? The answer is to build servers on top of it and make it complicated so big corporations will pay big bucks for it. That is why we have Java EE specs, JSRs, Weblogic, Websphere and other servers.</description>
    </item>
    
    <item>
      <title>Microservices</title>
      <link>https://networknt.github.io/architecture/microservices/</link>
      <pubDate>Sun, 09 Oct 2016 08:13:52 -0400</pubDate>
      
      <guid>https://networknt.github.io/architecture/microservices/</guid>
      <description>#
Speed and Safety at Scale and in Harmony.
If you’re like most software developers, team leaders, and architects responsible for getting working code out the door of your company, this phrase describes your job in a nutshell. Most of you have probably struggled at this, too. Getting to market quickly seems to imply giving up a bit of safety. Or, conversely, making sure the system is safe, reliable, and resilient means slowing down the pace of feature and bug-fix releases.</description>
    </item>
    
  </channel>
</rss>